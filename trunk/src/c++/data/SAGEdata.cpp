#include <cassert>
#include "LSF/LSFfile.h"
#include "error/errorstream.h"
#include "error/bufferederrorstream.h"
#include "error/errormanip.h"
#include "error/errorbuf.h"
#include "func/evalfunc.h"
#include "data/SAGEdata.h"

namespace SAGE {
namespace APP  {

////////////////////////////////////////////////////////////////////////////
//          External helper functions for SAGE_Data                       //
////////////////////////////////////////////////////////////////////////////

/// Links a Type Probability model to the multipedigree.  It does this
/// by looking up the ped~ind in the model and setting the phenotype appropriately.
///
void
link_model_to_pedigree(RPED::RefMultiPedigree& mped, size_t m, Output_Streams& out)
{
  // Fetch the imodel:
  MLOCUS::inheritance_model & model = mped.info().marker_info(m);

  for(RPED::RefMultiPedigree::pedigree_iterator ped = mped.pedigree_begin(); ped != mped.pedigree_end(); ++ped)
  {
    for(RPED::RefMultiPedigree::member_const_iterator ind = ped->member_begin(); ind != ped->member_end(); ++ind)
    {
      // Determine if the individual is missing.  If not, then we can skip him/her.
      if(ped->info().phenotype_missing(ind->index(), m, model))
      {
        ped->info().set_phenotype((size_t) ind->index(), m, ped->name() + "~" + ind->name(), std::string(), model);
      }
    }
  }

  // Reset the name so this only happens once.
  model.set_name(mped.info().markers().name(m));
}

void
check_marker_data(RPED::RefMultiPedigree& mped, Output_Streams& out)
{
  for(size_t i = 0; i < mped.info().marker_count(); ++i)
  {
    MLOCUS::inheritance_model& model = mped.info().marker_info(i);

    if(model.allele_count() == 0)
    {
      out.errors() << priority(warning) << "No usable data found for "
                   << "marker '" << model.name() << "'.  This marker will "
                   << "be considered unknown for all analyses." << std::endl;

      model.add_allele("A", 1.0, true, true);
    }
    // Otherwise, this may be a marker generated by type probabilities.
    // Such a marker is marked by having a name different from what it
    // is in the map (add three ~'s)
    else if(toUpper(model.name()) == toUpper(mped.info().markers().name(i)) + "~~~")
    {
      link_model_to_pedigree(mped, i, out);
    }
  }
}

//============================================================================
//IMPLEMENTATION:  marker_order
//============================================================================
//
marker_order::marker_order()
    : my_imodel(0)
{}

marker_order::marker_order(const MLOCUS::inheritance_model_map* imodel)
    : my_imodel(imodel)
{
  // - Remember original marker order.
  //
  MLOCUS::inheritance_model_map::index_const_iterator  iter     = imodel->index_begin();
  MLOCUS::inheritance_model_map::index_const_iterator  end_iter = imodel->index_end();
  for(; iter != end_iter; ++iter)
  {
    my_marker_names.push_back(iter->first);
  }
}

marker_order::iterator
marker_order::begin() const
{
  return  iterator(this);
}

marker_order::iterator
marker_order::end() const
{
  return  iterator(this, true);
}

marker_order::iterator
marker_order::find(size_t imodel_index) const
{
  vector<string>::const_iterator  position;
  vector<string>::const_iterator  end = my_marker_names.end();
  position = std::find(my_marker_names.begin(), my_marker_names.end(), my_imodel->name(imodel_index));

  if(position == end)
  {
    return  iterator(this, true);
  }
  else
  {
    iterator  return_value(this);
    return_value.my_position = position;

    return  return_value;
  }
}

void
marker_order::remove_marker(const string& marker)
{
  vector<string>::iterator  iter = std::find(my_marker_names.begin(), my_marker_names.end(), toUpper(marker));

  assert(iter != my_marker_names.end());

  my_marker_names.erase(iter);
}

void
marker_order::dump() const
{
  cout << endl;

  vector<string>::const_iterator  iter     = my_marker_names.begin();
  vector<string>::const_iterator  end_iter = my_marker_names.end();
  for(; iter != end_iter; ++iter)
  {
    cout << *iter << endl;
  }
}

//============================================================================
//IMPLEMENTATION:  marker_order::iterator
//============================================================================
//
marker_order::iterator::iterator(const marker_order* mo, bool at_end)
    : my_marker_order(mo)
{
  if(at_end)
  {
    my_position = my_marker_order->my_marker_names.end();
  }
  else
  {
    my_position = my_marker_order->my_marker_names.begin();
  }
}

marker_order::iterator
marker_order::iterator::operator ++()
{
  ++my_position;

  return  *this;
}

bool
marker_order::iterator::operator ==(const marker_order::iterator& other) const
{
  return  my_marker_order == other.my_marker_order &&
          my_position == other.my_position;
}

bool
marker_order::iterator::operator !=(const marker_order::iterator& other) const
{
  return  ! operator ==(other);
}

bool
marker_order::iterator::operator >(const marker_order::iterator& other) const
{
  assert(my_marker_order == other.my_marker_order);

  return   my_position > other.my_position;
}

const MLOCUS::inheritance_model*
marker_order::iterator::operator *() const
{
  return  &((*my_marker_order->my_imodel)[imodel_index()]);
}

size_t
marker_order::iterator::imodel_index() const
{
  size_t  index = my_marker_order->my_imodel->index(*my_position);

  assert(index != (size_t)(-1));

  return  index;
}


//==================================================================
//
//  CONSTRUCTOR
//
//==================================================================
SAGE_Data::SAGE_Data(const std::string& program_name, bool debug)
      : my_program_name(program_name), my_output(program_name, debug), my_allele_delimiter('/')
{}


//==================================================================
//
//  DESTRUCTOR
//
//==================================================================
SAGE_Data::~SAGE_Data()
{ }

void
SAGE_Data::parse_cmdline(int argc, char** argv)
{
  try
  {
    my_parsed_arguments = ArgumentParser::parse_commandline(ArgumentParser::convert_args(argc, argv), my_cmdline_rules);
  }
  catch(const std::exception& e)
  {
    ArgumentParser::display_usage(my_program_name, my_cmdline_rules, cout);

    exit(0);
  }
}

//==================================================================
//
//  read_parameter_file(...)
//
//==================================================================
bool
SAGE_Data::read_parameter_file(const std::string& fname)
{
  std::cout << "Reading Parameter File...................." << flush;

  ifstream in_state(fname.c_str());

  if(!in_state.good())
  {
    errors() << priority(fatal) << "Unable to load parameters....  Exiting." <<std::endl;
    exit(EXIT_FAILURE);
  }

  LSF_input load_state(in_state, std::cout);
  assert(load_state.good());

  my_params = new LSFBase("Parameters");
  load_state.input_to(my_params, false);

  if( !my_params || !my_params->List() )
  {
    errors() << priority(fatal) << "Error reading parameter file....  Exiting." << std::endl;

    exit(EXIT_FAILURE);
  }

  parse_pheno_info();

  std::cout << "done." << std::endl;

  return true;
}


//==================================================================
//
//  parse_pheno_info()
//
//==================================================================
void
SAGE_Data::parse_pheno_info()
{
  // Set up some storage for our two delimiter strings.  These will be used
  // only if there is not a MARKER block so are saved for later.
  char allele_delimiter       = '/';
  char marker_delimiter       = '/';
  bool found_marker_delimiter = false;

  // Iterate through the parameter file and look for MARKER, ALLELE_DELIMITER and/or
  // MARKER_DELIMITER tags.
  for(LSFList::const_iterator i = my_params->List()->begin(); i != my_params->List()->end(); ++i)
  {
    if(!*i || !(*i)->name().size())
      continue;

    std::string name = toUpper((*i)->name());

    if(name == "MARKER")
    {
      // If we have a MARKER block, read it into the pedigree's info.
      my_pedigrees.info().read_pheno_reader_info(*i, errors());
    }
    else if(name == "ALLELE_DELIMITER")
    {
      // If we have an allele delimiter, parse and store it for later
      AttrVal v = attr_value(*i,0);

      if(v.has_value() && v.String().size())
      {
        allele_delimiter = v.String()[0];
      }
    }
    else if(name == "MARKER_DELIMITER")
    {
      // If we have a marker delimiter, parse and store it for later
      AttrVal v = attr_value(*i,0);

      if(v.has_value() && v.String().size())
      {
        marker_delimiter       = v.String()[0];
        found_marker_delimiter = true;
      }
    }
  }

  // Choose MARKER_DELIMITER over ALLELE_DELIMITER
  char sep = (found_marker_delimiter) ? marker_delimiter : allele_delimiter;

  // If the sep character is different from '/' it can override a '/' character
  // in the PhenoReaderInfo object.  We check for that now
  RPED::PhenotypeReaderInfo & phreader = my_pedigrees.info().get_pheno_reader_info();

  if(phreader.get_allele_delimiter() != sep)
  {
    // IF they're different, we choose the non- '/' assuming that whatever the user
    // set, they meant it.  We choose the MARKER block version preferentially.
    if( phreader.get_allele_delimiter() == '/' )
    {
      phreader.set_allele_delimiter(sep);
    }
    else if(sep != '/')
    {
      // If *both* were not '/', there is an error that we need to deal with
      errors() << priority(warning)
               << "Two different non-default values were found for 'allele_delimiter'.  Will use '"
               << my_pedigrees.info().get_pheno_reader_info().get_allele_delimiter()
               << "' for the delimiter." << std::endl;
    }
  }
}

//==================================================================
//
//  read_family_data_file(...)
//
//==================================================================
bool
SAGE_Data::read_family_data_file(const std::string& fname,
                                 bool dump_trait,
                                 bool dump_marker,
                                 bool skip_traits,
                                 bool skip_markers,
                                 bool dynamic_markers)
{
  std::cout << "Reading Pedigree File....................." << std::endl;

  size_t marker_count   = my_pedigrees.info().marker_count();
  bool   dump_pairs     = false;
  bool   pedigree_exist = false;

  for(LSFList::const_iterator i = my_params->List()->begin(); i != my_params->List()->end(); ++i )
  {
    if( !*i ) continue;

    if( toUpper((*i)->name()) == "PEDIGREE" )
    {
      pedigree_exist = true;
      break;
    }
  }

  if( !pedigree_exist )
  {
    errors() << priority(fatal)
             << "No pedigree specified....  Exiting."
             << std::endl;

    exit(EXIT_FAILURE);
  }

  bufferederrorstream<char>                   err_buffer        (errors());
  boost::scoped_ptr<RPED::RefLSFPedigreeFile> ped_reader;
  bool                                        pedigree_loaded =  false;
  size_t                                      f               =  0;

  for(LSFList::const_iterator i = my_params->List()->begin(); i != my_params->List()->end(); ++i )
  {
    if( toUpper( (*i)->name() ) == "DUMP_PAIRS" )
      dump_pairs = true;

    if( toUpper((*i)->name()) == "PEDIGREE" )
    {
      std::string pedigree_file;

      if( (*i)->attrs() )
        pedigree_file = (*i)->attrs()->StringAttr("file");

      if( !pedigree_file.size() )
        pedigree_file = fname;

      if( (*i)->attrs() && (*i)->attrs()->has_attr("column") )
      {
        ped_reader.reset(new RPED::RefLSFFortranPedigreeFile(err_buffer));
      }
      else
      {
        ped_reader.reset(new RPED::RefLSFDelimitedPedigreeFile(err_buffer));
      }

      std::cout << "              from " << pedigree_file << flush;

      ped_reader->set_force_skip_markers    (skip_markers);
      ped_reader->set_force_skip_traits     (skip_traits);
      ped_reader->set_force_dynamic_markers (dynamic_markers);

      if( !ped_reader->process_parameters(my_pedigrees.info(), *i) || !ped_reader->input(my_pedigrees, pedigree_file, info()) )
      {
        std::cout << std::endl;

        err_buffer.flush_buffer();

        errors() << priority(fatal) << "Error reading pedigree data from file '" << pedigree_file << "'." << std::endl;

        exit(EXIT_FAILURE);
      }

      // Print out a number of .'s equal to 23 - the filename size to line up the
      // columns
      char old_fill = std::cout.fill('.');

      if(pedigree_file.size() < 23)
      {
        std::cout << setw(23-pedigree_file.size()) << '.';
      }

      std::cout << "done." << std::endl;

      std::cout.fill(old_fill);

      err_buffer.flush_buffer();

      pedigree_loaded = true;

      if( f == 0 )
      {
        my_first_ten_ind.resize(ped_reader->get_ind_list().size());

        for( size_t ind = 0; ind < my_first_ten_ind.size(); ++ind )
          my_first_ten_ind[ind] = ped_reader->get_ind_list()[ind];
      }

      ped_reader->print_mped(my_pedigrees, pedigree_file, info(), dump_trait, dump_marker);

      ++f;
    }
  }

  if( !pedigree_loaded )
  {
    std::cout << std::endl;

    errors() << priority(fatal) << "No pedigree loaded....  Exiting." << std::endl;

    exit(EXIT_FAILURE);
  }

  if( !my_pedigrees.pedigree_count() )
  {
    errors() << priority(critical) << "No pedigree to analyze....  Exiting." << std::endl;

    exit(EXIT_FAILURE);
  }

  size_t error_count = 0;

  for(RPED::RefMultiPedigree::pedigree_const_iterator p = my_pedigrees.pedigree_begin(); p != my_pedigrees.pedigree_end(); ++p )
    error_count += p->error_count();

  if( error_count )
  {
    errors() << priority(error) << "Errors appear in pedigree data. Results may be incomplete." << std::endl;
  }

  std::cout << "Sorting Pedigrees........................." << flush;


  for(RPED::RefMultiPedigree::pedigree_iterator j  = my_pedigrees.pedigree_begin(); j != my_pedigrees.pedigree_end(); ++j )
    PedigreeSort(*j);

  std::cout << "done." << std::endl;

  // Check for basic structural errors
  check_family_data(my_pedigrees);

  check_marker_data(my_pedigrees, my_output);

  if( !skip_markers && dump_marker && marker_count )
    print_genome_info_file(markers());

  // - Remember original marker order.
  //
  my_marker_order = marker_order(&(my_pedigrees.info().markers()));

  return dump_pairs;
}

bool
SAGE_Data::read_locus_description_file(const std::string& fname)
{
  std::cout << "Reading Marker Locus Description File....." << flush;

  MLOCUS::InheritanceModelFile marker_reader(errors());

  if( !marker_reader.input(my_pedigrees.info().markers(), fname, my_pedigrees.info().get_pheno_reader_info()) )
  {
    std::cout << std::endl;

    errors() << priority(fatal) << "Error reading marker locus description from file '" << fname << "'." << std::endl;

    exit(EXIT_FAILURE);
  }

  std::cout << "done." << std::endl;
  return true;
}

bool
SAGE_Data::read_genome_description_file(const std::string& fname, bool multipoint, double distance)
{
  read_genome_description_file(fname);

  cerrormultistream m;

  m.insert(errors());

  my_genome = new RPED::LSFgenome_description(my_pedigrees.info(), m, my_regions, multipoint);

  my_genome->set_scan_distance(distance);

  return my_genome->build();
}

bool
SAGE_Data::read_genome_description_file(const std::string& fname)
{
  std::cout << "Reading Genome Description File..........." << flush;

  ifstream in_state(fname.c_str());

  if( !in_state.good() )
  {
    errors() << priority(fatal) << "Unable to load genome....  Exiting." << std::endl;

    exit(EXIT_FAILURE);
  }

  LSF_input load_state(in_state, std::cout);
  assert(load_state.good());

  LSF_ptr<LSFBase> s = new LSFBase("genome");
  load_state.input_to(s, false);

  if( !s || !s->List() )
  {
    errors() << priority(fatal) << "Error reading genome file....  Exiting." << std::endl;

    exit(EXIT_FAILURE);
  }

  my_regions = NULL;

  for(LSFList::iterator i = s->List()->begin(); i != s->List()->end(); ++i )
  {
    if( toUpper((*i)->name()) == "GENOME" )
    {
      my_regions = (*i);
      break;
    }
  }

  if( !my_regions || !my_regions->List() )
  {
    errors() << priority(fatal) << "Unable to find genome in file....  Exiting." << std::endl;

    exit(EXIT_FAILURE);
  }

  std::cout << "done." << std::endl;

  return true;
}


//
//--------------------------------------------------------------------------------
//

void
SAGE_Data::evaluate_functions(RPED::RefMultiPedigree& mped)
{
  size_t org_trait_count = mped.info().trait_count();

  cerrormultistream m;

  m.insert(errors());

  FUNC::FunctionEvaluator::evaluateFunction(mped, m, my_params);

  size_t new_trait_count = mped.info().trait_count();

  if( new_trait_count > org_trait_count )
    dump_new_traits(mped, org_trait_count);
}

//
//--------------------------------------------------------------------------------
//

void
SAGE_Data::print_genome_info_file(const MLOCUS::inheritance_model_map& markers) const
{
  MLOCUS::InheritanceModelFile marker_writer(errors());

  marker_writer.output(markers, "genome.inf");
}

//
//--------------------------------------------------------------------------------
//

/** Checks each pedigree for common errors, such as multiple subpedigrees or
 *  unconnecteds.  If any are there, it produces warning messages.
 *  Multiple subpedigrees are always reported.  Unconnecteds are only
 *  reported if there are connected individuals in the same pedigree.
 */
void
SAGE_Data::check_family_data(const RPED::RefMultiPedigree& mped)
{
  RPED::RefMultiPedigree::pedigree_const_iterator p;
  for( p = mped.pedigree_begin(); p != mped.pedigree_end(); ++p )
  {
    if(p->subpedigree_count() > 1)
    {
      errors() << priority(warning)
               << "Pedigree '" << p->name() << "' has "
               << p->subpedigree_count() << " constituent pedigrees which "
               << "are disjoint from one another.  This may not be intended.  "
               << "Results may be incorrect.  See manual for details on "
               << "constituent pedigrees." << std::endl;
    }
    if(p->unconnected_count() && p->subpedigree_count())
    {
      errors() << priority(warning)
               << "Unconnected individuals detected in pedigree '"
               << p->name() << "'.  This may not be intended.  Results may "
               << "be incorrect." << std::endl;
    }
  }
}

//
//--------------------------------------------------------------------------------
//

void
SAGE_Data::filter_trait(size_t t)
{
  if( trait_data_exist(t) )
    return;

  delete_trait(t);
}

void
SAGE_Data::filter_marker(size_t m)
{
  if( marker_data_exist(m) )
    return;

  delete_marker(m);
}

void
SAGE_Data::filter_traits()
{
  RPED::RefMPedInfo& m_info = my_pedigrees.info();

  size_t no_data_trait = (size_t)(-1);

  // check the trait data
  //
  for( size_t t = 0; t < m_info.trait_count(); ++t )
  {
    bool data_exist = trait_data_exist(t);

    if( !data_exist )
    {
      no_data_trait = t;
      break;
    }
  }

  if(no_data_trait == (size_t)(-1))
    return;

  delete_trait(no_data_trait);

  filter_traits();
}

// - Remove markers with no data.
//
void
SAGE_Data::filter_markers()
{
  RPED::RefMPedInfo& m_info = my_pedigrees.info();

  size_t no_data_marker = (size_t)(-1);

  // check the marker data
  //
  for( size_t m = 0; m < m_info.marker_count(); ++m )
  {
    bool data_exist = marker_data_exist(m);

    if( !data_exist )
    {
      no_data_marker = m;
      break;
    }
  }

  if(no_data_marker == (size_t)(-1))
    return;

  delete_marker(no_data_marker, ft_NO_DATA);
  filter_markers();
}

// - Remove markers with only one allele.
//
void
SAGE_Data::filter_single_allelic_markers()
{
  RPED::RefMPedInfo&  m_info = my_pedigrees.info();

  size_t  one_allele_marker = (size_t)(-1);

  // check the marker data
  //
  for(size_t m = 0; m < m_info.marker_count(); ++m)
  {
    bool one_allele = only_one_allele(m);

    if(one_allele)
    {
      one_allele_marker = m;
      break;
    }
  }

  if(one_allele_marker == (size_t)(-1))
    return;

  delete_marker(one_allele_marker, ft_SINGLE_ALLELE);
  filter_single_allelic_markers();
}

void
SAGE_Data::filter_x_linked_markers()
{
  RPED::RefMPedInfo& m_info = my_pedigrees.info();

  size_t x_linked_marker = (size_t)(-1);

  // check the marker data
  //
  for( size_t m = 0; m < m_info.marker_count(); ++m )
  {
    bool x_linked = m_info.marker_info(m).is_x_linked();

    if(x_linked)
      x_linked_marker = m;
  }

  if(x_linked_marker == (size_t)(-1))
    return;

  delete_marker(x_linked_marker, ft_X_LINKED);

  filter_x_linked_markers();
}

//
//--------------------------------------------------------------------------------
//

void
SAGE_Data::dump_new_traits(const RPED::RefMultiPedigree& mped, size_t org_trait_count) const
{
  const RPED::RefMPedInfo &mped_info = mped.info();

  size_t new_trait_count = mped_info.trait_count();

  ostream &messages = info();

  messages << std::endl << "New phenotypes for individuals created by function block(s) :"
           << std::endl << std::endl;

  messages << "     PED. ID       IND. ID     ";


  for( size_t t = org_trait_count; t < new_trait_count; ++ t )
    messages << "  " << setw(20) << mped_info.trait_info(t).name();

  messages << std::endl << "     ------------  ------------";

  for( size_t t = org_trait_count; t < new_trait_count; ++ t )
    messages << "  --------------------";

  messages << std::endl;

  for( size_t i = 0; i < my_first_ten_ind.size(); ++i )
  {
    std::string pn = my_first_ten_ind[i].first;
    std::string id = my_first_ten_ind[i].second;

    messages << "     " << setw(12) << pn <<    "  " << setw(12) << id;

    RPED::RefMultiPedigree::member_const_pointer mem = mped.member_find(pn, id);

    const RPED::RefPedInfo &ped_info = mem->pedigree()->info();

    for( size_t t = org_trait_count; t < new_trait_count; ++t )
    {
      std::string trait_value = mped_info.trait_info(t).string_missing_code();;
      if( !ped_info.trait_missing(mem->index(), t) )
        trait_value = doub2str(ped_info.trait(mem->index(), t));

      messages << "  " << setw(20) << trait_value;
    }

    messages << std::endl;
  }

  messages << std::endl << std::endl;
}

void
SAGE_Data::delete_trait(size_t t)
{
  RPED::RefMPedInfo& m_info = my_pedigrees.info();

  assert(t < m_info.trait_count());

  // remove no_data trait entries in MPedInfo & PedInfo
  //
  RPED::RefMultiPedigree::pedigree_iterator pi = my_pedigrees.pedigree_begin();

  for( ; pi != my_pedigrees.pedigree_end(); ++pi )
  {
    RPED::RefPedInfo& p_info = pi->info();
    p_info.remove_trait(t);
  }

  RPED::RefTraitInfo& model = m_info.trait_info(t);
  errors() << priority(warning)
           << "No usable data found for trait '"
           << model.name() << "'.  The trait will "
           << "be unavailable for all analyses." << std::endl;

  m_info.remove_trait_info(t);
}

void
SAGE_Data::delete_marker(size_t m, FilterType filter)
{
  RPED::RefMPedInfo & m_info = my_pedigrees.info();

  assert(m < m_info.marker_count());

  // remove marker entries in MPedInfo & PedInfo
  //
  RPED::RefMultiPedigree::pedigree_iterator pi = my_pedigrees.pedigree_begin();

  for( ; pi != my_pedigrees.pedigree_end(); ++pi )
  {
    RPED::RefPedInfo& p_info = pi->info();
    p_info.remove_marker(m);
  }

  MLOCUS::inheritance_model& model = m_info.marker_info(m);
  const string  model_name = model.name();

  switch(filter)
  {
    case ft_NO_DATA:
      errors() << priority(warning)
               << "No usable data found for marker '"
               << model_name << "'.  This marker will "
               << "be unavailable for all analyses." << std::endl;
      break;

    case ft_SINGLE_ALLELE:
      errors() << priority(warning)
               << "Marker '"
               << model_name << "' has only one allele.  This marker will "
               << "be unavailable for all analyses." << std::endl;
      break;

    case ft_X_LINKED:
      errors() << priority(warning)
               << "Marker '"
               << model_name << "' is x_linked.  This marker will "
               << "be unavailable for all analyses." << std::endl;
      break;

    case ft_NONE:
      break;

    default:
      assert(false);
  }

  m_info.remove_marker_info(m);
  my_marker_order.remove_marker(model_name);
}

bool
SAGE_Data::trait_data_exist(size_t t) const
{
  // check the trait data
  //
  bool data_exist = false;

  RPED::RefMultiPedigree::pedigree_const_iterator pi = my_pedigrees.pedigree_begin();

  for( ; pi != my_pedigrees.pedigree_end() && !data_exist; ++pi )
  {
    const RPED::RefPedInfo& p_info = pi->info();

    for( size_t i = 0; i < p_info.member_count(); ++i )
    {
      if( !p_info.trait_missing(i, t) )
      {
        data_exist = true;
        break;
      }
    }
  }

  return data_exist;
}

bool
SAGE_Data::marker_data_exist(size_t m) const
{
  const RPED::RefMPedInfo& m_info = my_pedigrees.info();

  // check the marker data
  //
  bool data_exist = false;

  RPED::RefMultiPedigree::pedigree_const_iterator pi = my_pedigrees.pedigree_begin();

  for( ; pi != my_pedigrees.pedigree_end() && !data_exist; ++pi )
  {
    const RPED::RefPedInfo& p_info = pi->info();

    for( size_t i = 0; i < p_info.member_count(); ++i )
    {
      if( !p_info.phenotype_missing(i, m, m_info.marker_info(m)) )
      {
        data_exist = true;
        break;
      }
    }
  }

  return data_exist;
}

bool
SAGE_Data::only_one_allele(size_t m) const
{
  const RPED::RefMPedInfo& m_info = my_pedigrees.info();

  assert(m < m_info.marker_count());

  return  m_info.marker_info(m).allele_count() == 1;
}


} // End namespace APP
} // End namespace SAGE

