#include "segreg/AnalysisController.h"
#include "segreg/analysis.h"
#include "segreg/analysis_out.h"
#include "segreg/iterative_models.h"

#define gsmsm genotype_specific_mean_sub_model
#define tmsm  transmission_sub_model

namespace SAGE   {
namespace SEGREG {

//===================
// Output routine
//===================


void produce_output(const primary_analysis_results& a, APP::Output_Streams& o, bool append = false)
{

  const model& md = a.get_final_model();

  string file = a.get_final_model().get_file_name_root();

  string summary = file + ".sum";

  ios::openmode mode = ios::out;

  if(append) mode |= ios::app;

  ofstream s(summary.c_str(), mode);

  s<<left;

  analysis_result_file avs(s);

  avs.print_header (a);
  avs.print_results(a);
  avs.print_footer (a);

  string details = file + ".det";

  ofstream d(details.c_str(), mode);

  d << left;

  analysis_detailed_file avd(d, o.get_debug_status());

  avd.print_header (a);
  avd.print_results(a);
  avd.print_footer (a);

  // If we are to generate a penetrance file:

  if(a.get_final_model().get_type_prob())
  {
    // Eventually move this into its own function

    ofstream o((file + ".typ").c_str());

    o << "#! Type Probability File, version 1.1." << endl
      << "#  This file is automatically generated.  Do not edit!" << endl << endl;

    o << "Model=\"" << file << "\",title=\"" << a.get_final_model().get_title() << "\"" << endl;
    o << "{" << endl;

    // Print out the allele frequencies

    o << "  alleles" << endl
      << "  {" << endl;

    o << "    A = " << md.freq_sub_model.freq_A() << endl;
    o << "    B = " << (1 - md.freq_sub_model.freq_A()) << endl;

    o << "  }" << endl;

    pg::dump_post_genos(o, a.get_type_probs());
    
    o << "}" << endl;
  }

  if(a.get_final_model().get_pen_func_output())
  {
    // Eventually move this into its own function

    ofstream o((file + ".pen").c_str());

    o << "#! Penetrance Probability File, version 1.1." << endl
      << "#  This file is automatically generated.  Do not edit!" << endl << endl;

    o << "Model=\"" << file << "\",title=\"" << a.get_final_model().get_title() << "\"" << endl;
    o << "{" << endl;

    // Print out the allele frequencies

    o << "  alleles" << endl
      << "  {" << endl;

    o << "    A = " << md.freq_sub_model.freq_A() << endl;
    o << "    B = " << (1 - md.freq_sub_model.freq_A()) << endl;

    o << "  }" << endl;

    pf::dump_pen_func(o, a.get_pfunc_probs());

    o << "}" << endl;
  }
}

void produce_binary_nt_no_resid_error(const model& md, APP::Output_Streams& o, bool append = false)
{
  string file = md.get_file_name_root();

  string summary = file + ".sum";

  ios::openmode mode = ios::out;

  if(append) mode |= ios::app;

  ofstream s(summary.c_str(), mode);

  s << left;

  analysis_output::output_model (s, md);

  s << "  The maximum likelihood for this model is identical to that for a" << endl
    << "  one susceptibility model and there is an infinity of sets of maximum" << endl
    << "  likelihood estimates that yield the same maximum likelihood." << endl
    << endl;

  string details = file + ".det";

  ofstream d(details.c_str(), mode);

  d << left;

  analysis_output::output_model (d, md);

  d << "  The maximum likelihood for this model is identical to that for a" << endl
    << "  one susceptibility model and there is an infinity of sets of maximum" << endl
    << "  likelihood estimates that yield the same maximum likelihood." << endl
    << endl;
}

//===========================
// AnalysisController
//===========================

/// Create an analysis-specific dataset, and, if the dataset is valid, perform
/// the analysis
void AnalysisController::do_analysis
        (const RPED::MultiPedigree& mp,
         const model&               target_model) const
{
  print_analysis_header(target_model.get_title());

  PedigreeDataSet ped_data(mp, target_model, my_out);
  
  if(ped_data.is_valid())
    process_analysis(ped_data, target_model);

  print_analysis_footer();
}

/// Determine what analyses to perform, do them, and produce appropriate output.
void AnalysisController::process_analysis
      (const PedigreeDataSet& ped_data,
       const model&           target_model) const
{
      model::cond_mem_set.clear();
      if (fpmm_and_no_poly_loci > 0) { // addition by JA , original code resumes below
      analysis_output::skip_poly_locus = true;
     } else {
      analysis_output::skip_poly_locus = false;
    }

     primary_analysis::like_cutoff = like_cutoff;
 
  // Copy the model.  We make all our modifications to the test_model.

  model test_model = target_model;
  
  // due to JA, for single function evaluation when all parameters are fixed

       if (check_all_fixed(ped_data, test_model)) {
        double func_val;
        vector<string> par_type;
        par_type.clear();
        string file = test_model.get_file_name_root();
        vector<std::pair<string,double> > name_val;
        name_val = do_single_evaluation(ped_data, test_model, func_val, par_type); 
        produce_allfixed_output(name_val,par_type,func_val, file);
        return;} 


// Defining members of the conditioned subset
// Iterate over all members and insert members of the 
// Conditioned Subset in cond_mem_set 

     if (test_model.ascer_sub_model.s_option() != ascertainment_sub_model::none)
    {
      std::list<FPED::MemberConstPointer>::iterator listit;
      std::list<FPED::MemberConstPointer> mems = ped_data.getMemberList();
      for (listit = mems.begin(); listit != mems.end(); ++listit) {
       if (test_model.ascer_sub_model.is_ind_in_C(*listit)) \
        model::cond_mem_set.insert(*listit);
       }
     }
 
  // normal service resumes 

  // Determine if we have to do a Commingling analysis

  if(test_model.get_type_missing())
  {
    do_commingling_analysis(ped_data, test_model);
    return;
  }

  // Determine if we have to do a Transmission analysis

  genotype_specific_sub_model::sm_option m_model = test_model.type_dependent_sub_model().option();

  if(test_model.get_trans_missing() && m_model != genotype_specific_sub_model::one)
  {
    do_segregation_analysis(ped_data, test_model);
    return;
  }

  // Store the variance model for later

  genotype_specific_variance_sub_model var = target_model.var_sub_model;

  // Test to see if the mean, var, transm, freq and fpmm (if used) are
  // complete.  If so, we can do the simple regression analysis.

  bool use_fpmm      = test_model.get_model_class() == model_FPMM;
  bool fpmm_complete = !use_fpmm || test_model.fpmm_sub_model.is_complete();

  bool use_var       = test_model.get_model_class() != model_MLM;
  bool var_complete  = !use_var || test_model.var_sub_model.is_complete();

  if(test_model.type_dependent_sub_model() .is_complete() &&
     test_model.transm_sub_model           .is_complete() &&
     test_model.freq_sub_model             .is_complete() &&
     var_complete                                         &&
     fpmm_complete)
  {
    do_reg_analysis(ped_data, test_model);
    return;
  }

  // Otherwise, we must create a valid model.  This is done iteratively

  Iterative_Models ma(ped_data, my_out, my_analysis);

  ma.set_target_model(test_model);
  ma.set_output(true);

  ma.set_output_mean(true);
  ma.set_output_transm(true);

  // Determine what option is desired

  gsmsm::sm_option mean = test_model.type_dependent_sub_model().option();

  Iterative_Models::intermax.clear();

  // Run the iteration

  const primary_analysis_results& results = 
      ma.get_model( mean, test_model.transm_sub_model.option() );

  // At this point, all is done except potentially the variance model

  // If there are no variance adjustments, we just produce our output and
  // leave

  if(var.option() == genotype_specific_variance_sub_model::one)
  {
    if (Iterative_Models::intermax.size() == 0)
    {produce_output(results, my_out);} 
    else {
     for (unsigned i = 0; i != Iterative_Models::intermax.size(); i++){
       primary_analysis_results these_results = Iterative_Models::intermax[i];
       if (i == 0) produce_output(these_results,my_out,false);
       if (i > 0) produce_output(these_results,my_out,true);
       }
    }
   return; 
  }

  // At this point, the variance is known to be != one.  We must therefore
  // run one last maximization with the appropriate variance model.

  test_model = results.get_final_model();

  if(!var.is_complete())
  {
    double v = test_model.var_sub_model.parameter(index_AA);

    switch(var.option())
    {
      case genotype_specific_variance_sub_model::two       :
          test_model.var_sub_model.set(
              genotype_specific_variance_sub_model::two,
              v, QNAN, v, false,false);
          break;

      case genotype_specific_variance_sub_model::three     :
          test_model.var_sub_model.set(
              genotype_specific_variance_sub_model::three,
              v, v, v, false,false);
          break;

      case genotype_specific_variance_sub_model::two_dom   :
          test_model.var_sub_model.set(
              genotype_specific_variance_sub_model::two_dom,
              v, v, v, false,false);
          break;

      case genotype_specific_variance_sub_model::two_rec   :
          test_model.var_sub_model.set(
              genotype_specific_variance_sub_model::two_rec,
              v, v, v, false,false);
          break;

      case genotype_specific_variance_sub_model::three_add :
          test_model.var_sub_model.set(
              genotype_specific_variance_sub_model::three_add,
              v, v, v, false,false);
          break;
          
      case genotype_specific_variance_sub_model::one       :
          // Handled previously
          break;
          
      case genotype_specific_variance_sub_model::three_dec :
      case genotype_specific_variance_sub_model::three_inc :
          // These cases are not variance sm cases 
          break;
    }
  }
  else
    test_model.var_sub_model = var;

  // Finally, we run the last maximization

  do_reg_analysis(ped_data, test_model);

}

/// Perform a commingling analysis
///
void 
AnalysisController::do_commingling_analysis
    (const PedigreeDataSet& ped_data, 
     model& test_model) const
{
  Iterative_Models ma(ped_data, my_out, my_analysis);

  ma.set_target_model(test_model);
  ma.set_output(true);

  ma.set_output_mean(true);
  ma.set_output_transm(false);

  tmsm::sm_option hnt = tmsm::homog_no_trans;

  const primary_analysis_results& one_mean_results   = ma.get_model(gsmsm::one,   hnt);
  produce_output(one_mean_results, my_out,   false);
  
  const primary_analysis_results& two_mean_results   = ma.get_model(gsmsm::two,   hnt);
  produce_output(two_mean_results, my_out,   true);
  
  const primary_analysis_results& three_mean_results = ma.get_model(gsmsm::three, hnt);
  produce_output(three_mean_results, my_out, true);
  
  // print commingling analysis likelihood table
              
  string file = test_model.get_file_name_root();
          
  string details = file + ".det";
     
  ofstream d(details.c_str(), ios::app);
                
  analysis_output::output_likelihood_table_header  (d,test_model);
  analysis_output::output_likelihood_table_results (d,one_mean_results);
  analysis_output::output_likelihood_table_results (d,two_mean_results);
  analysis_output::output_likelihood_table_results (d,three_mean_results);
  analysis_output::output_likelihood_table_footer  (d);

}

/// Perform a segregation analysis
///
void 
AnalysisController::do_segregation_analysis
    (const PedigreeDataSet& ped_data, 
     model& test_model) const
{
  Iterative_Models ma(ped_data, my_out, my_analysis);

  ma.set_target_model(test_model);
  ma.set_output(true);

  ma.set_output_mean(true);
  ma.set_output_transm(true);

  gsmsm::sm_option mo = test_model.type_dependent_sub_model().option();

  // We analyze all applicable transmission models.  This means we can skip
  // no_trans, as it is the same as homog_no_trans under Hardy-Weinburg, and
  // we can skip homog_no_trans if it's a binary (MLM) model with no
  // residuals

  bool do_hnt = test_model.get_model_class() != model_MLM ||
                test_model.resid_sub_model.has_residuals();

  primary_analysis_results hnt_results;

  if(do_hnt)
  {
    hnt_results   = ma.get_model(mo, tmsm::homog_no_trans);
    produce_output(hnt_results, my_out, false);
  }
  else
  {
    produce_binary_nt_no_resid_error(test_model, my_out, false);
  }

  // All the other models we always do.

  primary_analysis_results mnd_results   = ma.get_model(mo, tmsm::homog_mendelian);
  produce_output(mnd_results, my_out, true);

  primary_analysis_results hgn_results   = ma.get_model(mo, tmsm::homog_general);
  produce_output(hgn_results, my_out, true);

  primary_analysis_results tab_results   = ma.get_model(mo, tmsm::tau_ab_free);
  produce_output(tab_results, my_out, true);

  primary_analysis_results gnl_results   = ma.get_model(mo, tmsm::general);
  produce_output(gnl_results, my_out, true);

  // print segregation analysis likelihood table

  string file = test_model.get_file_name_root();
  
  string details = file + ".det";
  
  ofstream d(details.c_str(), ios::app);
  
  analysis_output::output_likelihood_table_header  (d,test_model);

  if(do_hnt) analysis_output::output_likelihood_table_results (d,hnt_results);

  analysis_output::output_likelihood_table_results (d,mnd_results);
  analysis_output::output_likelihood_table_results (d,hgn_results);
  analysis_output::output_likelihood_table_results (d,tab_results);
  analysis_output::output_likelihood_table_results (d,gnl_results);

  analysis_output::output_likelihood_table_footer  (d);

  // fill up vector for p-value table
  vector<primary_analysis_results>	my_results;

  if(do_hnt && hnt_results.is_valid()) my_results.push_back(hnt_results);
  if(          mnd_results.is_valid()) my_results.push_back(mnd_results);
  if(          hgn_results.is_valid()) my_results.push_back(hgn_results);
  if(          tab_results.is_valid()) my_results.push_back(tab_results);
  if(          gnl_results.is_valid()) my_results.push_back(gnl_results);
  
  analysis_output::output_asymptotic_p_value_results(d,my_results);

}

/// Perform a basic regression analysis
///
void AnalysisController::do_reg_analysis
    (const PedigreeDataSet& ped_data, 
     model& m) const
{
  
  // Create our internal model

  vector<model> vm(1);

  vm[0] = m;

  // Run the analysis and get results

  const primary_analysis_results& results = my_analysis.run_analysis(ped_data, vm);

  // Deal with output if the results are valid

  if(results.is_valid())
    produce_output(results, my_out);

    if(Iterative_Models::intermax.size() > 0){ // due to JA, from earlier maxfun runs
      for(unsigned i = 0; i != Iterative_Models::intermax.size(); i++){
        primary_analysis_results these_results = Iterative_Models::intermax[i];
        produce_output(these_results,my_out);
      }
    }
}

/// Print the header for the analysis
///
void
  AnalysisController::print_analysis_header
    (const std::string&     title) const
{
  my_out.messages()
       << "  Performing analysis: " << title << endl
       << "  ==========================================================================="
       << endl << endl;
}

/// Print the footer for the analysis
///
void
  AnalysisController::print_analysis_footer( ) const
{
  my_out.messages()
       << endl
       << "  ==========================================================================="
       << endl << endl;
}

bool AnalysisController::check_all_fixed(const PedigreeDataSet& ped_data, const model& test_model) const
// We check for at least one parameter to be maximized
{ 
      primary_analysis* dummy_analysis = new primary_analysis(my_out); // delete at end

      bool all_fixed = dummy_analysis->check_all_fixed(ped_data, test_model);

      delete dummy_analysis;

      
      return all_fixed;
}

vector< std::pair<string,double> > 
AnalysisController::do_single_evaluation( const PedigreeDataSet& ped_data, const model& test_model, double& func_val, \
vector<string>& par_type) const
{
      vector< std::pair<string,double> > name_val = \
      my_analysis.do_single_evaluation(ped_data, test_model, func_val, par_type);
      
      return name_val;
}


void AnalysisController::produce_allfixed_output
    (vector<std::pair<string, double> > name_val, vector<string> par_type, double value, string file) const
{

  string summary = file + ".sum";

  ofstream out(summary.c_str(), ios::out);

  out << "  # Final Values : " << endl;
  out << endl;
  out << "  Parameter           Parameter Est.      Parameter Type" << endl;
  out << "-----------------------------------------------------------------------------------------------------" << endl;

  for( unsigned i = 0; i != name_val.size(); ++i )
  {
    std::pair<string,double> current_pair = name_val[i];
    string current_string = current_pair.first;
    double current_val = current_pair.second;
    
   if ( (current_string.substr(0,5) == "polyg") && (analysis_output::skip_poly_locus) )continue; // addition by JA

    out << left  << setw(2) << " " << setw(15) << current_string.substr(0,15);
    out << right << setw(5) << " " << setw(11) << setprecision(8) << current_val;
    out << left  << "           " << setw(6) << par_type[i] << endl;

   
  }
  out << "-----------------------------------------------------------------------------------------------------" << endl;

  out << endl;

  out << " The value of the log likelihood is " << setprecision(5) << setw(12) << value << endl;

  out << "-----------------------------------------------------------------------------------------------------" << endl;
}

} // End SEGREG namespace
} // End SAGE namespace

